####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        self.lsdb = {self.addr: {'links': {}, 'seq_num': 0}}
        self.forwarding_table = {} ##dest = port
        self.links_data = {} #{port: (endpoint, cost]}
        self.seq_num = 0

    def dijkstra(self):
        # use lsdb to calculate
        f = {}
        for addr in self.lsdb: f[addr] = 360000
        f[self.addr] = 0


        # Do minh chi dijsktra tren router, day la buoc minh convert client thanh router
        cli_to_router = {}
        cli_list = set()
        for a in self.lsdb:
            for po, (neighbor, cost) in self.lsdb[a]['links'].items():
                if(neighbor >= 'a' and neighbor <= 'z' and neighbor not in cli_list):
                    cli_list.add(neighbor)
                    cli_to_router[neighbor] = a

        # pre-dijsktra
        pre = {}
        port = {}
        visited = set()
        for addr in self.lsdb: pre[addr] = addr

        #Gan port cho cac hang xom,tuc la muon den endpoint thi di qua port: p
        # chuan bi de sau khi dijsktra xong se dung cai nay doi voi cac router o xa
        for p in self.links_data:
            endpoint = self.links_data[p][0]
            port[endpoint] = p

        #Dijsktra
        pq = [(0, self.addr)]
        while pq:
            dist, u = heapq.heappop(pq)
            if u in visited:
                continue
            visited.add(u)
            for po, (neighbor, cost) in self.lsdb[u]['links'].items():
                if neighbor in f and dist + cost < f[neighbor]:
                    f[neighbor] = dist + cost
                    pre[neighbor] = u
                    heapq.heappush(pq, (f[neighbor], neighbor))

        new_fw_table = {}

        #Truy vet, new_fw_table[addr] = port[x] tuc la muon di toi addr thi di qua port[x]
        #port[x]: x o day chinh la hang xom cua router hien tai, port[x] tuc la muon di toi x thi di qua port[x]
        #         den dc thang hang xom r tinh tiep
        for addr in self.lsdb:
            if f[addr] == 360000:
                continue
            if addr == self.addr:
                new_fw_table[addr] = -1
                continue
            x = addr
            while(pre[x] != self.addr):
                x = pre[x]
            new_fw_table[addr] = port[x]

        #Cai nay la cap nhat routing table cho addr cua client do chung ta chi dijkstra tren cac router
        # client nay la tat cac cac client ma chung ta den duoc, de den duoc day thi ta di toi router cam
        # truc tiep vao no
        for x in cli_list:
            if f[cli_to_router[x]] == 360000:
                continue
            new_fw_table[x] = new_fw_table[cli_to_router[x]]

        #Cai nay la gan truc tiep cong dau ra neu router cam thang vao client, cai ben tren chi chi chung ta den cac router
        #cam truc tiep vao no nhung no muon dung cong nao thi phai do thang nay
        addr = self.addr
        for po, (neighbor, cost) in self.lsdb[addr]['links'].items():
            if (neighbor >= 'a' and neighbor <= 'z'):
                new_fw_table[neighbor] = po

        self.forwarding_table = new_fw_table
        return


    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            if packet.dst_addr in self.forwarding_table and packet.dst_addr is not self.addr:
                self.send(self.forwarding_table[packet.dst_addr], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            content = json.loads(packet.content)
            seq_num = content['seq_num']

            links = {port: tuple(link) for port, link in content['links'].items()}

            if packet.src_addr not in self.lsdb or seq_num > self.lsdb[packet.src_addr]['seq_num']:
                self.lsdb[packet.src_addr] = {'links': links, 'seq_num': seq_num}
                self.dijkstra()
                for p in self.links_data:
                    if p != port:
                        self.send(p, packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.links_data[port]= (endpoint, cost)

        self.seq_num += 1
        self.lsdb[self.addr] = {
            'links': {p: (ep, c) for p, (ep, c) in self.links_data.items()},
            'seq_num': self.seq_num
        }

        self.dijkstra()

        content = json.dumps({'links': self.lsdb[self.addr]['links'], 'seq_num': self.seq_num})
        packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=None, content=content)

        for p in self.links_data:
            self.send(p, packet)
        return

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        if port in self.links_data:

            old = self.links_data.copy()
            del self.links_data[port]

            self.seq_num += 1
            self.lsdb[self.addr] = {
                'links': {p: (ep, c) for p, (ep, c) in self.links_data.items()},
                'seq_num': self.seq_num
            }

            self.dijkstra()

            content = json.dumps({'links': self.lsdb[self.addr]['links'], 'seq_num': self.seq_num})
            packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=None, content=content)

            for p in old:
                self.send(p, packet)
            return

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #  broadcast the link state of this router to all neighbors
            self.seq_num += 1

            self.lsdb[self.addr] = {
                'links': {p: (ep, c) for p, (ep, c) in self.links_data.items()},
                'seq_num': self.seq_num
            }

            content = json.dumps({'links': self.lsdb[self.addr]['links'], 'seq_num': self.seq_num})
            packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=None, content=content)
            for p in self.links_data:
                self.send(p, packet)

    def __repr__(self):
        return (
            f"LSrouter(addr={self.addr}, seq_num={self.seq_num}, "
            f"links_data={self.links_data}, "
            f"forwarding_table={self.forwarding_table}, "
            f"lsdb={self.lsdb}), "
            f"real_links={self.links[1].e2}"
        )


